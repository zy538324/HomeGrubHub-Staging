{% extends "base.html" %}

{% block title %}Barcode Scanner - HomeGrubHub{% endblock %}

{% block extra_styles %}
<style>
.scanner-container {
        max-width: 1200px;
        margin: 0 auto 40px auto;
        padding: 30px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: auto;
        position: relative;
        overflow: hidden;
        border-radius: 20px;
    }
    
    .scanner-container::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="grain" width="100" height="100" patternUnits="userSpaceOnUse"><circle cx="25" cy="25" r="1" fill="white" opacity="0.05"/><circle cx="75" cy="75" r="1" fill="white" opacity="0.05"/><circle cx="50" cy="10" r="1" fill="white" opacity="0.03"/></pattern></defs><rect width="100" height="100" fill="url(%23grain)"/></svg>');
        pointer-events: none;
    }
    
    .scanner-container > * {
        position: relative;
        z-index: 1;
    }
    
    .scanner-container h1 {
        color: white;
        text-align: center;
        margin-bottom: 15px;
        font-weight: 700;
        text-shadow: 0 4px 8px rgba(0,0,0,0.3);
        font-size: 2.5rem;
    }
    
    .scanner-container p.text-muted {
        text-align: center;
        color: rgba(255,255,255,0.9);
        margin-bottom: 40px;
        font-size: 18px;
        font-weight: 400;
    }
    
    /* Camera and Scanner Styling */
    .camera-container {
        max-width: 450px;
        margin: 0 auto 30px;
        border-radius: 20px;
        overflow: hidden;
        box-shadow: 0 20px 40px rgba(0,0,0,0.2);
        background: rgba(255,255,255,0.1);
        backdrop-filter: blur(20px);
        border: 2px solid rgba(255,255,255,0.2);
        position: relative;
        height: 280px;
    }
    
    .camera-container::before {
        content: '';
        position: absolute;
        top: -2px;
        left: -2px;
        right: -2px;
        bottom: -2px;
        background: linear-gradient(45deg, rgba(255,255,255,0.3), rgba(255,255,255,0.1));
        border-radius: 20px;
        z-index: -1;
    }
    
    #camera-feed {
        width: 100%;
        height: 280px;
        object-fit: cover;
        display: block;
        background: #000;
        border-radius: 18px;
    }
    
    .scanner-overlay {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: min(180px, 60vw);
        height: min(90px, 18vh);
        border: 3px solid #00ff00;
        border-radius: 12px;
        pointer-events: none;
        box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.3);
        backdrop-filter: blur(2px);
    }
    
    .scanner-line {
        position: absolute;
        width: 100%;
        height: 3px;
        background: linear-gradient(90deg, transparent, #00ff00, transparent);
        animation: scan 2s linear infinite;
        border-radius: 2px;
        box-shadow: 0 0 10px #00ff00;
    }
    
    @keyframes scan {
        0% { top: 0; opacity: 1; }
        50% { opacity: 0.8; }
        100% { top: calc(100% - 3px); opacity: 1; }
    }
    
    .scanner-status {
        text-align: center;
        padding: 20px 25px;
        border-radius: 15px;
        margin: 25px 0;
        font-weight: 600;
        font-size: 16px;
        box-shadow: 0 8px 25px rgba(0,0,0,0.2);
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 12px;
        backdrop-filter: blur(20px);
        border: 1px solid rgba(255,255,255,0.2);
    }
    
    .status-ready {
        background: rgba(132, 250, 176, 0.15);
        color: white;
        border-color: rgba(132, 250, 176, 0.3);
    }
    
    .status-scanning {
        background: rgba(168, 237, 234, 0.15);
        color: white;
        animation: pulse 2s infinite;
        border-color: rgba(168, 237, 234, 0.3);
    }
    
    .status-success {
        background: rgba(39, 174, 96, 0.15);
        color: #2ecc71;
        border-color: rgba(39, 174, 96, 0.3);
    }
    
    .status-error {
        background: rgba(231, 76, 60, 0.15);
        color: #e74c3c;
        border-color: rgba(231, 76, 60, 0.3);
    }
    
    @keyframes pulse {
        0% { transform: scale(1); }
        50% { transform: scale(1.02); }
        100% { transform: scale(1); }
    }
    
    /* Button Styling */
    .scanner-controls {
        text-align: center;
        margin: 25px 0;
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 15px;
    }
    
    .btn-scanner {
        background: linear-gradient(45deg, #667eea 0%, #764ba2 100%);
        border: none;
        color: white;
        padding: 14px 28px;
        border-radius: 12px;
        font-weight: 600;
        margin: 0;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 6px 20px rgba(102, 126, 234, 0.3);
        font-size: 14px;
        min-width: 130px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        position: relative;
        overflow: hidden;
    }
    
    .btn-scanner::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
        transition: left 0.5s;
    }
    
    .btn-scanner:hover::before {
        left: 100%;
    }
    
    .btn-scanner:hover:not(:disabled) {
        transform: translateY(-3px);
        box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
        background: linear-gradient(45deg, #764ba2 0%, #667eea 100%);
    }
    
    .btn-start {
        background: linear-gradient(45deg, #28a745 0%, #20c997 100%);
        box-shadow: 0 6px 20px rgba(40, 167, 69, 0.3);
    }
    
    .btn-start:hover {
        background: linear-gradient(45deg, #20c997 0%, #28a745 100%);
        box-shadow: 0 10px 30px rgba(40, 167, 69, 0.4);
    }
    
    .btn-stop {
        background: linear-gradient(45deg, #ff6b6b 0%, #ee5a24 100%);
        box-shadow: 0 6px 20px rgba(255, 107, 107, 0.3);
    }
    
    .btn-stop:hover {
        background: linear-gradient(45deg, #ee5a24 0%, #ff6b6b 100%);
        box-shadow: 0 10px 30px rgba(255, 107, 107, 0.4);
    }
    
    .btn-toggle {
        background: linear-gradient(45deg, #4ecdc4 0%, #44a08d 100%);
        box-shadow: 0 6px 20px rgba(78, 205, 196, 0.3);
    }
    
    .btn-toggle:hover {
        background: linear-gradient(45deg, #44a08d 0%, #4ecdc4 100%);
        box-shadow: 0 10px 30px rgba(78, 205, 196, 0.4);
    }
    
    .btn-scanner:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        transform: none;
        background: rgba(108, 117, 125, 0.5) !important;
        box-shadow: none !important;
    }
    
    /* Camera Selector */
    .camera-selector {
        background: rgba(255,255,255,0.1);
        backdrop-filter: blur(20px);
        border: 1px solid rgba(255,255,255,0.2);
        padding: 25px;
        border-radius: 15px;
        margin: 25px auto;
        max-width: 450px;
        text-align: center;
        box-shadow: 0 8px 25px rgba(0,0,0,0.1);
    }
    
    .camera-selector label {
        color: white;
        font-weight: 600;
        margin-bottom: 15px;
        display: block;
        font-size: 16px;
    }
    
    .product-result {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 30px;
        border-radius: 20px;
        margin: 30px 0;
        box-shadow: 0 15px 35px rgba(0,0,0,0.15);
        border: none;
        position: relative;
        overflow: hidden;
        max-width: 900px;
        margin-left: auto;
        margin-right: auto;
    }
    
    .product-result::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="grain" width="100" height="100" patternUnits="userSpaceOnUse"><circle cx="25" cy="25" r="1" fill="white" opacity="0.05"/><circle cx="75" cy="75" r="1" fill="white" opacity="0.05"/><circle cx="50" cy="10" r="1" fill="white" opacity="0.03"/></pattern></defs><rect width="100" height="100" fill="url(%23grain)"/></svg>');
        pointer-events: none;
    }
    
    .product-result > * {
        position: relative;
        z-index: 1;
    }
    
    .product-result h3 {
        margin-bottom: 15px;
        font-size: 24px;
        font-weight: 700;
    }
    
    .product-image {
        max-width: 200px;
        max-height: 200px;
        border-radius: 15px;
        box-shadow: 0 8px 25px rgba(0,0,0,0.2);
        margin: 20px 0;
        display: block;
        border: 3px solid rgba(255,255,255,0.2);
    }
    
    /* Nutrition Grid */
    .nutrition-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 15px;
        margin: 20px 0;
    }
    
    .nutrition-item {
        background: rgba(255,255,255,0.15);
        padding: 15px;
        border-radius: 15px;
        text-align: center;
        backdrop-filter: blur(15px);
        border: 1px solid rgba(255,255,255,0.2);
        transition: all 0.3s ease;
        position: relative;
        overflow: hidden;
    }
    
    .nutrition-item::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
        transition: left 0.5s;
    }
    
    .nutrition-item:hover::before {
        left: 100%;
    }
    
    .nutrition-item:hover {
        background: rgba(255,255,255,0.25);
        transform: translateY(-3px);
        box-shadow: 0 8px 25px rgba(0,0,0,0.2);
    }
    
    .nutrition-value {
        font-size: 22px;
        font-weight: 700;
        margin-bottom: 8px;
        color: #fff;
    }
    
    .nutrition-label {
        font-size: 12px;
        color: rgba(255,255,255,0.9);
        text-transform: uppercase;
        letter-spacing: 0.8px;
        font-weight: 500;
    }
    
    /* Calculator Section */
    .calorie-calculator {
        background: rgba(255,255,255,0.1);
        backdrop-filter: blur(20px);
        border: 1px solid rgba(255,255,255,0.2);
        border-radius: 20px;
        padding: 25px;
        margin-top: 25px;
        transition: all 0.3s ease;
        position: relative;
        overflow: hidden;
    }
    
    .calorie-calculator::before {
        content: '';
        position: absolute;
        top: -2px;
        left: -2px;
        right: -2px;
        bottom: -2px;
        background: linear-gradient(45deg, rgba(255,255,255,0.3), rgba(255,255,255,0.1));
        border-radius: 20px;
        z-index: -1;
    }
    
    .calorie-calculator:hover {
        background: rgba(255,255,255,0.15);
        box-shadow: 0 10px 30px rgba(0,0,0,0.15);
        transform: translateY(-2px);
    }
    
    .calorie-calculator h5 {
        color: white;
        margin-bottom: 20px;
        font-weight: 600;
    }
    
    .nutrition-facts {
        font-family: 'Arial', sans-serif;
        line-height: 1.6;
        background: white;
        color: #2c3e50;
        border-radius: 15px;
        overflow: hidden;
        max-width: 400px;
        margin: 0 auto;
    }
    
    .nutrition-facts div {
        padding: 12px 0;
        border-bottom: 1px solid #ecf0f1;
    }
    
    .nutrition-facts strong {
        font-weight: 700;
    }
    
    .manual-input {
        background: rgba(255,255,255,0.1);
        backdrop-filter: blur(20px);
        border: 1px solid rgba(255,255,255,0.2);
        border-radius: 20px;
        padding: 30px;
        margin: 30px auto;
        max-width: 600px;
        transition: all 0.3s ease;
        position: relative;
        overflow: hidden;
    }
    
    .manual-input::before {
        content: '';
        position: absolute;
        top: -2px;
        left: -2px;
        right: -2px;
        bottom: -2px;
        background: linear-gradient(45deg, rgba(255,255,255,0.3), rgba(255,255,255,0.1));
        border-radius: 20px;
        z-index: -1;
    }
    
    .manual-input:hover {
        background: rgba(255,255,255,0.15);
        box-shadow: 0 10px 30px rgba(0,0,0,0.15);
        transform: translateY(-2px);
    }
    
    .manual-input h5 {
        color: white;
        margin-bottom: 20px;
        font-weight: 600;
        text-align: center;
    }
    
    .form-group {
        margin: 20px 0;
        text-align: center;
        position: relative;
        z-index: 1;
    }
    
    .form-group label {
        color: white;
        font-weight: 600;
        margin-bottom: 10px;
        display: block;
    }
    
    .form-control {
        max-width: 400px;
        margin: 10px auto;
        padding: 12px 16px;
        border: 1px solid rgba(255,255,255,0.3);
        border-radius: 12px;
        font-size: 16px;
        transition: all 0.3s ease;
        background: rgba(255,255,255,0.9);
        backdrop-filter: blur(10px);
        color: #2c3e50;
    }
    
    .form-control:focus {
        background: rgba(255,255,255,1);
        border-color: #007bff;
        box-shadow: 0 0 20px rgba(0,123,255,0.3);
        outline: none;
    }
    
    .btn-primary {
        background: linear-gradient(45deg, #007bff, #0056b3);
        border: none;
        color: white;
        border-radius: 12px;
        padding: 12px 30px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 1px;
        transition: all 0.3s ease;
        box-shadow: 0 5px 15px rgba(0,123,255,0.3);
        margin-top: 15px;
    }
    
    .btn-primary:hover {
        background: linear-gradient(45deg, #0056b3, #004085);
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(0,123,255,0.4);
    }
    
    .search-results {
        max-height: 300px;
        overflow-y: auto;
        background: rgba(255,255,255,0.1);
        backdrop-filter: blur(20px);
        border: 1px solid rgba(255,255,255,0.2);
        border-radius: 15px;
        margin-top: 15px;
        box-shadow: 0 8px 25px rgba(0,0,0,0.1);
    }
    
    .search-item {
        padding: 15px;
        border-bottom: 1px solid rgba(255,255,255,0.1);
        cursor: pointer;
        transition: all 0.3s ease;
        color: white;
        background: rgba(255,255,255,0.05);
    }
    
    .search-item:hover {
        background: rgba(255,255,255,0.15);
        transform: translateX(5px);
        box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    }
    
    .search-item:last-child {
        border-bottom: none;
    }
    
    .permission-notice {
        background: rgba(255,255,255,0.15);
        backdrop-filter: blur(20px);
        border: 2px solid rgba(0,123,255,0.8);
        border-radius: 15px;
        padding: 25px;
        margin: 25px 0;
        text-align: center;
        color: white;
        box-shadow: 0 8px 25px rgba(0,123,255,0.2);
    }
    
    .device-info {
        background: rgba(255,255,255,0.15);
        backdrop-filter: blur(20px);
        border: 2px solid rgba(255,193,7,0.8);
        border-radius: 15px;
        padding: 25px;
        margin: 25px 0;
        text-align: center;
        color: rgb(3, 1, 1);
        box-shadow: 0 8px 25px rgba(255,193,7,0.2);
    }
    
    /* Mobile-specific optimizations */
    @media (max-width: 768px) {
        body {
            background-attachment: scroll;
        }
        
        .scanner-container {
            margin: 10px;
            padding: 20px;
            backdrop-filter: blur(15px);
        }
        
        .camera-container {
            max-width: 100%;
            height: 250px;
        }
        
        .manual-input {
            margin: 20px 10px;
            padding: 20px;
        }
        
        .product-result {
            margin: 20px 10px;
            padding: 20px;
        }
        
        .form-control {
            max-width: 100%;
        }
        
        #camera-feed {
            min-height: 200px;
            max-height: 250px;
        }
        
        .scanner-overlay {
            width: min(150px, 60vw);
            height: min(75px, 15vh);
            border-width: 2px;
        }
        
        .nutrition-grid {
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }
        
        .btn-scanner {
            padding: 10px 15px;
            font-size: 14px;
            min-width: 100px;
        }
        
        .scanner-controls {
            gap: 8px;
        }
        
        .nutrition-item {
            padding: 12px;
        }
        
        .nutrition-value {
            font-size: 18px;
        }
        }
        
        .nutrition-facts {
            max-width: 100%;
            margin: 15px 0;
        }
        
        .form-control {
            padding: 10px 12px;
            font-size: 16px; /* Prevents zoom on iOS */
        }
    
    
    /* iOS Safari specific fixes */
    @supports (-webkit-touch-callout: none) {
        #camera-feed {
            -webkit-transform: translateZ(0);
            transform: translateZ(0);
        }
        
        .camera-container {
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
        }
    }
    
    /* Android Chrome specific fixes */
    @media screen and (-webkit-min-device-pixel-ratio: 0) {
        .camera-container {
            contain: layout style paint;
        }
    }
    
    /* Fullscreen mode for better scanning */
    .fullscreen-scanner {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 9999;
        background: #000;
        display: flex;
        flex-direction: column;
    }
    
    .fullscreen-controls {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 10000;
    }
    
    .torch-btn {
        background: rgba(255, 255, 255, 0.9);
        border: none;
        border-radius: 50%;
        width: 60px;
        height: 60px;
        margin: 0 10px;
        font-size: 24px;
        cursor: pointer;
        transition: all 0.3s;
    }
    
    .torch-btn:hover {
        background: white;
        transform: scale(1.1);
    }
</style>
{% endblock %}

{% block content %}
<div class="scanner-container">
    <h1><i class="fas fa-barcode"></i> Barcode Scanner</h1>
    <p class="text-muted">Scan product barcodes to quickly add ingredients and create recipes</p>
    
    <!-- Scanner Status -->
    <div id="scanner-status" class="scanner-status status-ready">
        Ready to scan
    </div>
    
    <!-- Scanning Tips -->
    <div id="scanning-tips" class="alert alert-info" style="display: none; margin: 15px 0;">
        <h6><i class="fas fa-lightbulb"></i> Scanning Tips:</h6>
        <ul class="mb-0" style="text-align: left;">
            <li>Position the barcode in the green rectangle</li>
            <li>Keep the barcode straight and well-lit</li>
            <li>Hold steady for 1-2 seconds</li>
            <li>Use the flashlight button if needed</li>
            <li>Try different distances if not detecting</li>
        </ul>
    </div>
    
    <!-- Camera Container -->
    <div class="camera-container" id="camera-container" style="display: none;">
        <video id="camera-feed" autoplay playsinline></video>
        <div class="scanner-overlay">
            <div class="scanner-line"></div>
        </div>
    </div>
    
    <!-- Scanner Controls -->
    <div class="scanner-controls">
        <button id="start-camera" class="btn-scanner btn-start">
            <i class="fas fa-camera"></i> Start Camera
        </button>
        <button id="stop-camera" class="btn-scanner btn-stop" style="display: none;">
            <i class="fas fa-stop"></i> Stop Camera
        </button>
        <button id="toggle-camera" class="btn-scanner btn-toggle" style="display: none;">
            <i class="fas fa-sync-alt"></i> Switch Camera
        </button>
    </div>
    
    <!-- Camera Selector -->
    <div id="camera-selector" class="camera-selector" style="display: none; margin: 15px 0;">
        <label for="camera-select"><i class="fas fa-camera"></i> Select Camera:</label>
        <select id="camera-select" class="form-control" style="margin-top: 5px;">
            <!-- Options will be populated by JavaScript -->
        </select>
    </div>
    
    <!-- Manual Barcode Input -->
    <div class="manual-input">
        <h3><i class="fas fa-keyboard"></i> Manual Entry</h3>
        <div class="form-group">
            <label for="manual-barcode">Enter Barcode Manually:</label>
            <input type="text" id="manual-barcode" class="form-control" placeholder="e.g., 8901030801234">
            <button id="search-barcode" class="btn btn-primary" style="margin-top: 10px;">
                <i class="fas fa-search"></i> Search Product
            </button>
        </div>
        
        <!-- Test Barcode Buttons -->
        <div class="form-group">
            <label>Test with Known Products:</label>
            <div style="margin-top: 10px;">
                <button class="btn btn-outline-secondary btn-sm me-2 mb-2" onclick="testBarcode('3017620422003')">
                    <i class="fas fa-vial"></i> Test Nutella
                </button>
                <button class="btn btn-outline-secondary btn-sm me-2 mb-2" onclick="testBarcode('5449000000996')">
                    <i class="fas fa-vial"></i> Test Coca-Cola
                </button>
                <button class="btn btn-outline-secondary btn-sm me-2 mb-2" onclick="testBarcode('4025700001030')">
                    <i class="fas fa-vial"></i> Test Milka
                </button>
            </div>
        </div>
        
        <div class="form-group">
            <label for="product-search">Or Search by Product Name:</label>
            <input type="text" id="product-search" class="form-control" placeholder="e.g., Coca Cola">
            <div id="search-results" class="search-results" style="display: none;"></div>
        </div>
    </div>
    
    <!-- Product Result -->
    <div id="product-result" style="display: none;"></div>
</div>

<!-- Include QuaggaJS for barcode scanning -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/quagga/0.12.1/quagga.min.js"></script>

<script>
// Global variables for caching scanned products
let scannedProducts = {};
let calculatedNutrition = {};

class BarcodeScanner {
    constructor() {
        this.isScanning = false;
        this.stream = null;
        this.cameras = [];
        this.currentCameraIndex = 0;
        this.lastScanTime = 0;
        this.scanCooldown = 1500; // Reduced cooldown for faster scanning
        this.isMobile = this.detectMobile();
        this.torchSupported = false;
        this.torchEnabled = false;
        
        this.initializeElements();
        this.setupEventListeners();
        this.setupMobileOptimizations();
        // Don't check camera support immediately - wait for user interaction
        this.updateStatus('Ready to scan - Click "Start Camera" to begin', 'ready');
    }
    
    detectMobile() {
        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
               (navigator.maxTouchPoints && navigator.maxTouchPoints > 0);
    }
    
    initializeElements() {
        this.elements = {
            startBtn: document.getElementById('start-camera'),
            stopBtn: document.getElementById('stop-camera'),
            toggleBtn: document.getElementById('toggle-camera'),
            cameraContainer: document.getElementById('camera-container'),
            cameraFeed: document.getElementById('camera-feed'),
            status: document.getElementById('scanner-status'),
            manualBarcode: document.getElementById('manual-barcode'),
            searchBtn: document.getElementById('search-barcode'),
            productSearch: document.getElementById('product-search'),
            searchResults: document.getElementById('search-results'),
            productResult: document.getElementById('product-result'),
            cameraSelect: document.getElementById('camera-select'),
            cameraSelector: document.getElementById('camera-selector')
        };
    }
    
    setupEventListeners() {
        this.elements.startBtn.addEventListener('click', () => this.startScanning());
        this.elements.stopBtn.addEventListener('click', () => this.stopScanning());
        this.elements.toggleBtn.addEventListener('click', () => this.switchCamera());
        this.elements.searchBtn.addEventListener('click', () => this.searchManualBarcode());
        this.elements.manualBarcode.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') this.searchManualBarcode();
        });
        this.elements.productSearch.addEventListener('input', () => this.searchProducts());
        
        // Camera selector change event
        this.elements.cameraSelect.addEventListener('change', (e) => {
            const selectedIndex = parseInt(e.target.value);
            if (selectedIndex !== this.currentCameraIndex) {
                this.currentCameraIndex = selectedIndex;
                if (this.isScanning) {
                    this.switchCamera();
                }
            }
        });
        
        // Handle visibility change (for mobile apps going to background)
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && this.isScanning) {
                this.pauseScanning();
            } else if (!document.hidden && this.stream) {
                this.resumeScanning();
            }
        });
        
        // Handle orientation change
        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                if (this.isScanning) {
                    this.restartScanning();
                }
            }, 500);
        });
    }
    
    setupMobileOptimizations() {
        if (this.isMobile) {
            // Add mobile-specific UI enhancements
            this.addMobileFeatures();
            
            // Prevent zoom on form inputs
            const viewportMeta = document.querySelector('meta[name="viewport"]');
            if (viewportMeta) {
                viewportMeta.content = 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no';
            }
        }
    }
    
    addMobileFeatures() {
        // Add fullscreen button for mobile
        const fullscreenBtn = document.createElement('button');
        fullscreenBtn.className = 'btn-scanner btn-toggle';
        fullscreenBtn.innerHTML = '<i class="fas fa-expand"></i> Fullscreen';
        fullscreenBtn.addEventListener('click', () => this.toggleFullscreen());
        
        const controls = document.querySelector('.scanner-controls');
        controls.appendChild(fullscreenBtn);
        
        // Add torch button if supported
        this.addTorchButton();
    }
    
    addTorchButton() {
        const torchBtn = document.createElement('button');
        torchBtn.id = 'torch-btn';
        torchBtn.className = 'btn-scanner btn-toggle';
        torchBtn.innerHTML = '<i class="fas fa-flashlight"></i> Flash';
        torchBtn.style.display = 'none';
        torchBtn.addEventListener('click', () => this.toggleTorch());
        
        const controls = document.querySelector('.scanner-controls');
        controls.appendChild(torchBtn);
    }
    
    async checkCameraSupport() {
        try {
            // Check if mediaDevices API is available
            if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
                throw new Error('Camera API not supported');
            }
            
            // Request permission first to get proper camera labels
            try {
                const tempStream = await navigator.mediaDevices.getUserMedia({ video: true });
                tempStream.getTracks().forEach(track => track.stop());
                console.log('Camera permission granted - will enumerate with labels');
            } catch (permError) {
                console.log('Permission not granted yet - will enumerate without labels');
            }
            
            // Now enumerate devices (should have labels if permission granted)
            const devices = await navigator.mediaDevices.enumerateDevices();
            this.cameras = devices.filter(device => device.kind === 'videoinput');
            
            console.log('Available cameras:', this.cameras.map(cam => ({
                deviceId: cam.deviceId,
                label: cam.label || 'Unknown Camera',
                groupId: cam.groupId
            })));
            
            // Try to select the best camera for barcode scanning
            this.selectBestCamera();
            
            if (this.cameras.length === 0) {
                this.updateStatus('No cameras found on this device', 'error');
                this.elements.startBtn.disabled = true;
            } else {
                this.updateStatus(`${this.cameras.length} camera(s) found - Ready to scan`, 'ready');
                if (this.cameras.length > 1) {
                    this.elements.toggleBtn.style.display = 'inline-block';
                    this.elements.cameraSelector.style.display = 'block';
                    this.populateCameraSelector();
                    console.log('Multiple cameras detected - showing switch button and selector');
                } else {
                    console.log('Single camera detected');
                }
                this.showDeviceInfo();
            }
        } catch (error) {
            console.error('Camera enumeration failed:', error);
            this.updateStatus('Camera support check failed: ' + error.message, 'error');
            // Don't disable the button - user might still grant permission
        }
    }
    
    populateCameraSelector() {
        this.elements.cameraSelect.innerHTML = '';
        this.cameras.forEach((camera, index) => {
            const option = document.createElement('option');
            option.value = index;
            
            // Create better camera descriptions
            let description = camera.label || `Camera ${index + 1}`;
            
            // Add facing information if we can determine it
            if (description.toLowerCase().includes('front') || description.toLowerCase().includes('user')) {
                description += ' (Front)';
            } else if (description.toLowerCase().includes('back') || description.toLowerCase().includes('environment') || description.toLowerCase().includes('rear')) {
                description += ' (Back)';
            } else if (this.isMobile) {
                // Make educated guess for mobile
                description += index === 0 ? ' (Likely Front)' : ' (Likely Back)';
            }
            
            option.textContent = description;
            if (index === this.currentCameraIndex) {
                option.selected = true;
            }
            this.elements.cameraSelect.appendChild(option);
        });
    }
    
    selectBestCamera() {
        if (this.cameras.length <= 1) return;
        
        console.log('Selecting best camera from:', this.cameras.map(c => c.label || 'Unlabeled'));
        
        // On mobile, prefer back/environment camera for barcode scanning
        if (this.isMobile) {
            // First try to find by label
            let backCameraIndex = this.cameras.findIndex(camera => {
                const label = (camera.label || '').toLowerCase();
                return label.includes('back') || 
                       label.includes('environment') || 
                       label.includes('rear') ||
                       label.includes('world') ||
                       (label.includes('camera') && label.includes('0')); // Sometimes back camera is camera 0
            });
            
            // If no labeled back camera found, try using constraints
            if (backCameraIndex === -1) {
                console.log('No labeled back camera found, will try environment facingMode');
                // We'll set currentCameraIndex to 1 if available (often the back camera)
                if (this.cameras.length > 1) {
                    this.currentCameraIndex = 1; // Try second camera
                    console.log('Selected camera index 1 as likely back camera');
                }
            } else {
                this.currentCameraIndex = backCameraIndex;
                console.log('Selected back camera:', this.cameras[backCameraIndex].label);
            }
        }
    }
    
    async requestCameraPermission() {
        try {
            // Check if getUserMedia is available
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                throw new Error('Camera access is not supported in this browser or context');
            }
            
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            stream.getTracks().forEach(track => track.stop());
            return true;
        } catch (error) {
            throw new Error('Camera permission denied: ' + error.message);
        }
    }
    
    showPermissionNotice() {
        const notice = document.createElement('div');
        notice.className = 'permission-notice';
        notice.innerHTML = `
            <h4><i class="fas fa-exclamation-triangle"></i> Camera Access Required</h4>
            <p>To scan barcodes, please allow camera access when prompted.</p>
            <p><strong>Requirements:</strong></p>
            <ul style="text-align: left; display: inline-block;">
                <li>Use HTTPS (not HTTP) for camera access</li>
                <li>Use a modern browser (Chrome, Firefox, Safari, Edge)</li>
                <li>Allow camera permissions when prompted</li>
                <li>On mobile: Tap camera icon in address bar and select "Allow"</li>
                <li>Try refreshing the page if it doesn't work initially</li>
            </ul>
        `;
        
        const container = document.querySelector('.scanner-container');
        container.insertBefore(notice, container.firstChild.nextSibling);
    }
    
    showDeviceInfo() {
        // Remove existing device info if any
        const existingInfo = document.querySelector('.device-info');
        if (existingInfo) {
            existingInfo.remove();
        }
        
        const deviceInfo = document.createElement('div');
        deviceInfo.className = 'device-info alert alert-info';
        
        let cameraDetails = '';
        if (this.cameras.length > 0) {
            cameraDetails = this.cameras.map((camera, index) => {
                const isActive = index === this.currentCameraIndex;
                const label = camera.label || `Camera ${index + 1}`;
                const facing = label.toLowerCase().includes('front') ? '(Front)' : 
                              label.toLowerCase().includes('back') ? '(Back)' : 
                              label.toLowerCase().includes('environment') ? '(Back)' : '';
                return `${isActive ? '<strong>' : ''}${label} ${facing}${isActive ? ' (Active)</strong>' : ''}`;
            }).join('<br>');
        }
        
        deviceInfo.innerHTML = `
            <div style="margin-bottom: 10px;">
                <strong><i class="fas fa-info-circle"></i> Camera Status:</strong><br>
                ${this.isMobile ? '<i class="fas fa-mobile-alt"></i> Mobile Device' : '<i class="fas fa-desktop"></i> Desktop'} | 
                ${this.cameras.length} Camera(s) Available
                ${this.cameras.length > 1 ? ' | <i class="fas fa-sync-alt"></i> Switch available' : ''}
            </div>
            ${cameraDetails ? `<div><strong>Available Cameras:</strong><br>${cameraDetails}</div>` : ''}
        `;
        
        const container = document.querySelector('.scanner-container');
        container.insertBefore(deviceInfo, this.elements.status.nextSibling);
    }
    
    async startScanning() {
        try {
            this.updateStatus('<i class="fas fa-spinner fa-spin status-icon"></i> Starting camera...', 'scanning');
            
            // Check if getUserMedia is available
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                throw new Error('Camera access is not supported in this browser or context. Please use HTTPS or a modern browser.');
            }
            
            // Check camera support first
            if (this.cameras.length === 0) {
                await this.checkCameraSupport();
            }
            
            // Get optimal constraints for the device
            const constraints = this.getOptimalConstraints();
            
            this.stream = await navigator.mediaDevices.getUserMedia(constraints);
            this.elements.cameraFeed.srcObject = this.stream;
            
            // Check for torch support
            await this.checkTorchSupport();
            
            // Wait for video to be ready
            await new Promise((resolve) => {
                this.elements.cameraFeed.addEventListener('loadedmetadata', resolve, { once: true });
            });
            
            // Initialize Quagga with optimized settings
            await this.initializeQuagga();
            
            this.isScanning = true;
            this.updateUI();
            this.updateStatus('<i class="fas fa-camera status-icon"></i> Scanning for barcodes...', 'scanning');
            
        } catch (error) {
            console.error('Camera start failed:', error);
            this.updateStatus('Failed to start camera: ' + error.message, 'error');
            this.showCameraErrorHelp(error);
        }
    }
    
    getOptimalConstraints() {
        const baseConstraints = {
            video: {}
        };
        
        // If we have a specific camera selected, try to use its deviceId
        if (this.cameras[this.currentCameraIndex]?.deviceId) {
            baseConstraints.video.deviceId = { exact: this.cameras[this.currentCameraIndex].deviceId };
            console.log('Using specific camera:', this.cameras[this.currentCameraIndex].label || `Camera ${this.currentCameraIndex + 1}`);
        }
        
        // Always add facingMode as backup constraint
        if (this.isMobile) {
            if (!baseConstraints.video.deviceId) {
                // If no specific device, use facingMode
                baseConstraints.video.facingMode = { ideal: 'environment' };
                console.log('Using facingMode: environment (back camera preferred)');
            } else {
                // Even with deviceId, add facingMode as fallback
                baseConstraints.video.facingMode = 'environment';
            }
        } else {
            if (!baseConstraints.video.deviceId) {
                baseConstraints.video.facingMode = { ideal: 'user' };
                console.log('Using facingMode: user (front camera)');
            }
        }
        
        // Mobile-optimized settings
        if (this.isMobile) {
            baseConstraints.video = {
                ...baseConstraints.video,
                width: { ideal: 1280, max: 1920 },
                height: { ideal: 720, max: 1080 },
                frameRate: { ideal: 30, max: 30 },
                focusMode: 'continuous',
                exposureMode: 'continuous'
            };
        } else {
            // Desktop settings
            baseConstraints.video = {
                ...baseConstraints.video,
                width: { ideal: 1920 },
                height: { ideal: 1080 },
                frameRate: { ideal: 30 },
                focusMode: 'continuous',
                exposureMode: 'continuous'
            };
        }
        
        console.log('Camera constraints:', baseConstraints);
        return baseConstraints;
    }
    
    async checkTorchSupport() {
        try {
            const track = this.stream.getVideoTracks()[0];
            const capabilities = track.getCapabilities();
            
            if (capabilities.torch) {
                this.torchSupported = true;
                const torchBtn = document.getElementById('torch-btn');
                if (torchBtn) {
                    torchBtn.style.display = 'inline-block';
                }
            }
        } catch (error) {
            console.log('Torch not supported:', error);
        }
    }
    
    async initializeQuagga() {
        return new Promise((resolve, reject) => {
            console.log('Initializing Quagga with enhanced settings...');
            Quagga.init({
                inputStream: {
                    name: "Live",
                    type: "LiveStream",
                    target: this.elements.cameraFeed,
                    constraints: {
                        width: { min: 640, ideal: 1280, max: 1920 },
                        height: { min: 480, ideal: 720, max: 1080 },
                        facingMode: this.isMobile ? 'environment' : 'user',
                        focusMode: 'continuous', // Better focus for barcode scanning
                        exposureMode: 'continuous'
                    }
                },
                decoder: {
                    readers: [
                        "code_128_reader",
                        "ean_reader",
                        "ean_8_reader",
                        "code_39_reader",
                        "code_39_vin_reader",
                        "codabar_reader",
                        "upc_reader",
                        "upc_e_reader",
                        "i2of5_reader"
                    ],
                    debug: {
                        showCanvas: false,
                        showPatches: false,
                        showFoundPatches: false,
                        showSkeleton: false,
                        showLabels: false,
                        showPatchLabels: false,
                        showRemainingPatchLabels: false,
                        boxFromPatches: {
                            showTransformed: false,
                            showTransformedBox: false,
                            showBB: false
                        }
                    }
                },
                locator: {
                    patchSize: this.isMobile ? "large" : "medium",
                    halfSample: false // Better quality detection
                },
                numOfWorkers: navigator.hardwareConcurrency || 2,
                frequency: this.isMobile ? 8 : 15, // Increased frequency for better detection
                locate: true
            }, (err) => {
                if (err) {
                    console.error('Quagga initialization failed:', err);
                    reject(err);
                    return;
                }
                
                console.log('Quagga initialized successfully');
                Quagga.start();
                resolve();
            });
            
            // Listen for barcode detection with enhanced logging
            Quagga.onDetected((data) => {
                console.log('Barcode detected:', data.codeResult.code, 'Quality:', data.codeResult.quality);
                
                const now = Date.now();
                if (now - this.lastScanTime < this.scanCooldown) {
                    console.log('Barcode ignored due to cooldown');
                    return;
                }
                
                this.lastScanTime = now;
                const barcode = data.codeResult.code;
                this.handleBarcodeDetected(barcode);
            });
            
            // Listen for processing events to debug detection issues
            Quagga.onProcessed((result) => {
                const drawingCtx = Quagga.canvas.ctx.overlay;
                const drawingCanvas = Quagga.canvas.dom.overlay;

                if (result) {
                    if (result.boxes) {
                        drawingCtx.clearRect(0, 0, parseInt(drawingCanvas.getAttribute("width")), parseInt(drawingCanvas.getAttribute("height")));
                        result.boxes.filter(function (box) {
                            return box !== result.box;
                        }).forEach(function (box) {
                            Quagga.ImageDebug.drawPath(box, {x: 0, y: 1}, drawingCtx, {color: "green", lineWidth: 2});
                        });
                    }

                    if (result.box) {
                        Quagga.ImageDebug.drawPath(result.box, {x: 0, y: 1}, drawingCtx, {color: "#00F", lineWidth: 2});
                    }

                    if (result.codeResult && result.codeResult.code) {
                        Quagga.ImageDebug.drawPath(result.line, {x: 'x', y: 'y'}, drawingCtx, {color: 'red', lineWidth: 3});
                    }
                }
            });
        });
    }
    
    async toggleTorch() {
        if (!this.torchSupported || !this.stream) return;
        
        try {
            const track = this.stream.getVideoTracks()[0];
            await track.applyConstraints({
                advanced: [{ torch: !this.torchEnabled }]
            });
            
            this.torchEnabled = !this.torchEnabled;
            const torchBtn = document.getElementById('torch-btn');
            if (torchBtn) {
                torchBtn.innerHTML = this.torchEnabled ? 
                    '<i class="fas fa-flashlight"></i> Flash On' : 
                    '<i class="fas fa-flashlight"></i> Flash Off';
                torchBtn.style.background = this.torchEnabled ? 
                    'linear-gradient(45deg, #ffc107, #fd7e14)' : 
                    'linear-gradient(45deg, #17a2b8, #007bff)';
            }
        } catch (error) {
            console.error('Torch toggle failed:', error);
        }
    }
    
    toggleFullscreen() {
        const container = this.elements.cameraContainer;
        
        if (!document.fullscreenElement) {
            container.requestFullscreen().then(() => {
                container.classList.add('fullscreen-scanner');
            }).catch(err => {
                console.log('Fullscreen failed:', err);
            });
        } else {
            document.exitFullscreen().then(() => {
                container.classList.remove('fullscreen-scanner');
            });
        }
    }

    pauseScanning() {
        if (this.isScanning) {
            Quagga.stop();
            this.updateStatus('Scanning paused', 'ready');
        }
    }
    
    resumeScanning() {
        if (this.stream && !this.isScanning) {
            Quagga.start();
            this.isScanning = true;
            this.updateStatus('Scanning resumed', 'scanning');
        }
    }
    
    async restartScanning() {
        if (this.isScanning) {
            this.stopScanning();
            setTimeout(() => this.startScanning(), 1000);
        }
    }
    
    showCameraErrorHelp(error) {
        let helpText = '';
        
        if (error.name === 'NotAllowedError') {
            helpText = 'Camera permission denied. Please refresh and allow camera access.';
        } else if (error.name === 'NotFoundError') {
            helpText = 'No camera found. Please connect a camera and try again.';
        } else if (error.name === 'NotReadableError') {
            helpText = 'Camera is busy. Close other apps using the camera and try again.';
        } else {
            helpText = 'Camera error. Try refreshing the page or using a different browser.';
        }
        
        const helpDiv = document.createElement('div');
        helpDiv.className = 'permission-notice';
        helpDiv.innerHTML = `<p><strong>Help:</strong> ${helpText}</p>`;
        
        const container = document.querySelector('.scanner-container');
        container.appendChild(helpDiv);
    }
    
    stopScanning() {
        if (this.stream) {
            this.stream.getTracks().forEach(track => track.stop());
            this.stream = null;
        }
        
        if (this.isScanning) {
            Quagga.stop();
            this.isScanning = false;
        }
        
        this.updateUI();
        this.updateStatus('Scanner stopped', 'ready');
    }
    
    async switchCamera() {
        if (this.cameras.length <= 1) {
            console.log('Cannot switch camera - only one camera available');
            return;
        }
        
        const oldIndex = this.currentCameraIndex;
        this.currentCameraIndex = (this.currentCameraIndex + 1) % this.cameras.length;
        
        const oldCamera = this.cameras[oldIndex]?.label || `Camera ${oldIndex + 1}`;
        const newCamera = this.cameras[this.currentCameraIndex]?.label || `Camera ${this.currentCameraIndex + 1}`;
        
        console.log(`Switching from ${oldCamera} to ${newCamera}`);
        this.updateStatus(`Switching to ${newCamera}...`, 'scanning');
        
        this.stopScanning();
        
        // Update device info to show new active camera
        this.showDeviceInfo();
        
        // Update camera selector dropdown
        if (this.elements.cameraSelect) {
            this.elements.cameraSelect.value = this.currentCameraIndex;
        }
        
        await this.startScanning();
    }
    
    updateUI() {
        const scanningTips = document.getElementById('scanning-tips');
        
        if (this.isScanning) {
            this.elements.startBtn.style.display = 'none';
            this.elements.stopBtn.style.display = 'inline-block';
            this.elements.cameraContainer.style.display = 'block';
            scanningTips.style.display = 'block'; // Show tips when scanning
            if (this.cameras.length > 1) {
                this.elements.toggleBtn.style.display = 'inline-block';
                // Update button text to show current camera
                const currentCamera = this.cameras[this.currentCameraIndex]?.label || `Camera ${this.currentCameraIndex + 1}`;
                const facing = currentCamera.toLowerCase().includes('front') ? 'Front' : 
                              currentCamera.toLowerCase().includes('back') ? 'Back' : 
                              currentCamera.toLowerCase().includes('environment') ? 'Back' : 'Unknown';
                this.elements.toggleBtn.innerHTML = `<i class="fas fa-sync-alt"></i> Switch (${facing})`;
            }
        } else {
            this.elements.startBtn.style.display = 'inline-block';
            this.elements.stopBtn.style.display = 'none';
            this.elements.toggleBtn.style.display = 'none';
            this.elements.cameraContainer.style.display = 'none';
            scanningTips.style.display = 'none'; // Hide tips when not scanning
        }
    }
    
    updateStatus(message, type) {
        this.elements.status.textContent = message;
        this.elements.status.className = `scanner-status status-${type}`;
    }
    
    async handleBarcodeDetected(barcode) {
        this.updateStatus(`Barcode detected: ${barcode}`, 'success');
        
        // Add visual feedback
        this.elements.cameraContainer.style.border = '3px solid #00ff00';
        setTimeout(() => {
            this.elements.cameraContainer.style.border = 'none';
        }, 1000);
        
        await this.lookupProduct(barcode);
    }
    
    async searchManualBarcode() {
        const barcode = this.elements.manualBarcode.value.trim();
        if (!barcode) return;
        
        await this.lookupProduct(barcode);
    }
    
    async lookupProduct(barcode) {
        try {
            this.updateStatus('Looking up product...', 'scanning');
            
            const response = await fetch(`/api/barcode/${barcode}`);
            const data = await response.json();
            
            if (data.success) {
                // Cache the product data for nutrition logging
                scannedProducts[barcode] = data.product;
                
                this.displayProduct(data.product, barcode);
                this.updateStatus('Product found!', 'success');
            } else {
                this.updateStatus('Product not found', 'error');
                this.elements.productResult.style.display = 'none';
            }
            
        } catch (error) {
            console.error('Product lookup failed:', error);
            this.updateStatus('Lookup failed', 'error');
        }
    }
    
    displayProduct(product, barcode) {
        const html = `
            <div class="product-result">
                <h3><i class="fas fa-box"></i> ${product.name}</h3>
                ${product.brand ? `<p><strong>Brand:</strong> ${product.brand}</p>` : ''}
                <p><strong>Barcode:</strong> ${barcode}</p>
                
                ${product.image_url ? `<img src="${product.image_url}" alt="${product.name}" class="product-image">` : ''}
                
                ${product.ingredients_text ? `
                    <div style="margin: 15px 0;">
                        <strong>Ingredients:</strong>
                        <p style="font-size: 14px; margin-top: 5px;">${product.ingredients_text}</p>
                    </div>
                ` : ''}
                
                ${product.nutrition ? `
                    <div style="margin: 20px 0;">
                        <strong>Nutrition (per 100g):</strong>
                        <div class="nutrition-grid">
                            ${Object.entries(product.nutrition)
                                .filter(([key, value]) => value && value.value !== null && value.value !== undefined)
                                .map(([key, value]) => `
                                <div class="nutrition-item">
                                    <div class="nutrition-value">${typeof value.value === 'number' ? value.value.toFixed(1) : value.value || 'N/A'}</div>
                                    <div class="nutrition-label">${value.label || key} ${value.unit ? `(${value.unit})` : ''}</div>
                                </div>
                            `).join('')}
                        </div>
                        
                        <!-- Calorie Calculator -->
                        <div class="calorie-calculator">
                            <h5><i class="fas fa-calculator"></i> Nutrition Calculator</h5>
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="form-group" style="margin-bottom: 10px;">
                                        <label for="portion-size-${barcode}" style="color: white; font-weight: 500;">Portion size (grams):</label>
                                        <input type="number" id="portion-size-${barcode}" class="form-control" value="100" min="1" max="5000" style="width: 120px; display: inline-block;">
                                    </div>
                                </div>
                                <div class="col-md-6">
                                    <div class="form-group" style="margin-bottom: 10px;">
                                        <label for="servings-input-${barcode}" style="color: white; font-weight: 500;">Number of servings to eat:</label>
                                        <input type="number" id="servings-input-${barcode}" class="form-control" value="1" min="1" max="100" style="width: 100px; display: inline-block;">
                                        <small style="color: rgba(255,255,255,0.8);">How many servings will you consume?</small>
                                    </div>
                                </div>
                            </div>
                            <button onclick="calculateNutritionPerServing('${barcode}')" class="btn btn-info btn-sm">
                                <i class="fas fa-calculator"></i> Calculate Total Nutrition
                            </button>
                            <small style="color: rgba(255,255,255,0.8); margin-top: 5px; display: block;">
                                This will show the total nutrition for all servings combined.
                            </small>
                            <div id="nutrition-per-serving-${barcode}" style="display: none; margin-top: 15px;"></div>
                        </div>
                    </div>
                ` : ''}
                
                ${product.dietary_info && product.dietary_info.length > 0 ? `
                    <div style="margin: 15px 0;">
                        <strong>Dietary Information:</strong>
                        <div style="margin-top: 5px;">
                            ${product.dietary_info.map(info => `
                                <span class="badge badge-info" style="margin-right: 5px;">${info}</span>
                            `).join('')}
                        </div>
                    </div>
                ` : ''}
                
                <div style="margin-top: 20px;">
                    <button class="btn btn-primary" onclick="createRecipeFromProduct('${barcode}')">
                        <i class="fas fa-plus"></i> Create Recipe
                    </button>
                    <button class="btn btn-secondary" onclick="addToShoppingList('${barcode}', this)">
                        <i class="fas fa-shopping-cart"></i> Add to Weekly Shopping
                    </button>
                    <button class="btn btn-success" onclick="showLogNutritionModal('${barcode}')">
                        <i class="fas fa-chart-line"></i> Log to Nutrition Tracker
                    </button>
                    <button class="btn btn-warning" onclick="addToPantry('${barcode}', this)">
                        <i class="fas fa-warehouse"></i> Add to Pantry
                    </button>
                </div>
            </div>
        `;
        
        this.elements.productResult.innerHTML = html;
        this.elements.productResult.style.display = 'block';
    }
    
    async searchProducts() {
        const query = this.elements.productSearch.value.trim();
        if (query.length < 3) {
            this.elements.searchResults.style.display = 'none';
            return;
        }
        
        try {
            const response = await fetch(`/api/search-products?q=${encodeURIComponent(query)}&limit=10`);
            const data = await response.json();
            
            if (data.success && data.products.length > 0) {
                this.displaySearchResults(data.products);
            } else {
                this.elements.searchResults.style.display = 'none';
            }
        } catch (error) {
            console.error('Product search failed:', error);
        }
    }
    
    displaySearchResults(products) {
        const html = products.map(product => `
            <div class="search-item" onclick="selectSearchResult('${product.barcode}')">
                <strong>${product.name}</strong>
                ${product.brand ? `<br><small>Brand: ${product.brand}</small>` : ''}
                <br><small>Barcode: ${product.barcode}</small>
            </div>
        `).join('');
        
        this.elements.searchResults.innerHTML = html;
        this.elements.searchResults.style.display = 'block';
    }
}

// Global functions
async function createRecipeFromProduct(barcode) {
    try {
        const response = await fetch('/create-recipe-from-barcode', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCsrfToken()
            },
            body: JSON.stringify({ barcode })
        });
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        
        if (data.success) {
            // Store recipe data and redirect
            sessionStorage.setItem('barcode_recipe_data', JSON.stringify(data.recipe_data));
            window.location.href = '/add_recipe?from_barcode=true';
        } else {
            showNotification('Failed to create recipe: ' + data.error, 'error');
        }
    } catch (error) {
        console.error('Recipe creation failed:', error);
        showNotification('Failed to create recipe', 'error');
    }
}

function addToShoppingList(barcode, buttonElement = null) {
    // Show modal to let user choose which shopping list to add to
    showShoppingListModal(barcode, buttonElement);
}

function showShoppingListModal(barcode, buttonElement) {
    // First, get available shopping lists
    fetch('/weekly-shopping/api/get-available-lists')
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                displayShoppingListModal(data.lists, barcode, buttonElement);
            } else {
                // Fallback to original behavior
                addToOriginalShoppingList(barcode, buttonElement);
            }
        })
        .catch(error => {
            console.error('Failed to load shopping lists:', error);
            // Fallback to original behavior
            addToOriginalShoppingList(barcode, buttonElement);
        });
}

function displayShoppingListModal(lists, barcode, buttonElement) {
    // Create modal HTML
    const modalHtml = `
        <div class="modal fade" id="shoppingListModal" tabindex="-1" aria-labelledby="shoppingListModalLabel" aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="shoppingListModalLabel">
                            <i class="fas fa-shopping-cart me-2"></i>Add to Shopping List
                        </h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <p class="mb-3">Choose which shopping list to add this item to:</p>
                        <div class="list-group">
                            ${lists.map(list => `
                                <button type="button" class="list-group-item list-group-item-action" 
                                        onclick="addToWeeklyShoppingList('${barcode}', ${list.id}, '${list.label}', this)">
                                    <div class="d-flex w-100 justify-content-between">
                                        <h6 class="mb-1">
                                            ${list.is_current ? '<i class="fas fa-star text-warning me-1"></i>' : ''}
                                            ${list.label}
                                        </h6>
                                        <small>${list.week_start} - ${list.week_end}</small>
                                    </div>
                                    <small class="text-muted">${list.items_count} items</small>
                                </button>
                            `).join('')}
                        </div>
                        
                        <hr class="my-3">
                        
                        <div class="d-grid">
                            <button type="button" class="btn btn-outline-secondary" 
                                    onclick="addToOriginalShoppingList('${barcode}', null)">
                                <i class="fas fa-list me-1"></i>Add to Current Shopping List (Legacy)
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    `;
    
    // Remove existing modal if any
    const existingModal = document.getElementById('shoppingListModal');
    if (existingModal) {
        existingModal.remove();
    }
    
    // Add modal to page
    document.body.insertAdjacentHTML('beforeend', modalHtml);
    
    // Show modal
    const modal = new bootstrap.Modal(document.getElementById('shoppingListModal'));
    modal.show();
}

function addToWeeklyShoppingList(barcode, weeklyListId, listLabel, buttonElement) {
    // Close the modal first
    const modal = bootstrap.Modal.getInstance(document.getElementById('shoppingListModal'));
    if (modal) {
        modal.hide();
    }
    
    // Show loading state
    if (buttonElement) {
        buttonElement.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Adding...';
        buttonElement.disabled = true;
    }
    
    fetch('/api/add-to-weekly-shopping-list', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCsrfToken()
        },
        body: JSON.stringify({ 
            barcode: barcode,
            weekly_list_id: weeklyListId
        })
    })
    .then(response => {
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        return response.json();
    })
    .then(data => {
        if (data.success) {
            showNotification(data.message, 'success');
            
            // Offer to redirect to the shopping list
            setTimeout(() => {
                if (confirm(`Item added successfully! Would you like to view ${listLabel}?`)) {
                    window.location.href = data.redirect_url;
                }
            }, 1000);
            
        } else {
            showNotification('Failed to add to shopping list: ' + data.error, 'error');
        }
    })
    .catch(error => {
        console.error('Shopping list error:', error);
        showNotification('Failed to add to shopping list', 'error');
    })
    .finally(() => {
        // Reset button state
        if (buttonElement) {
            buttonElement.disabled = false;
            buttonElement.innerHTML = listLabel;
        }
    });
}

function addToOriginalShoppingList(barcode, buttonElement) {
    // Close modal if open
    const modal = bootstrap.Modal.getInstance(document.getElementById('shoppingListModal'));
    if (modal) {
        modal.hide();
    }
    fetch('/api/add-to-shopping-list', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCsrfToken()
        },
        body: JSON.stringify({ barcode })
    })
    .then(response => {
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        return response.json();
    })
    .then(data => {
        if (data.success) {
            // Show success message with modern notification
            showNotification(data.message, 'success');
            
            // Update button to show it was added (if button element is provided)
            if (buttonElement) {
                const originalText = buttonElement.innerHTML;
                buttonElement.innerHTML = '<i class="fas fa-check"></i> Added!';
                buttonElement.style.background = 'linear-gradient(45deg, #28a745, #20c997)';
                
                setTimeout(() => {
                    buttonElement.innerHTML = originalText;
                    buttonElement.style.background = '';
                }, 2000);
            }
            
        } else {
            showNotification('Failed to add to shopping list: ' + data.error, 'error');
        }
    })
    .catch(error => {
        console.error('Shopping list error:', error);
        showNotification('Failed to add to shopping list', 'error');
    });
}

function showNotification(message, type) {
    // Create notification element
    const notification = document.createElement('div');
    notification.className = `notification notification-${type}`;
    notification.innerHTML = `
        <i class="fas fa-${type === 'success' ? 'check-circle' : 'exclamation-triangle'}"></i>
        ${message}
    `;
    
    // Add styles
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        padding: 15px 20px;
        border-radius: 8px;
        color: white;
        font-weight: 600;
        z-index: 10000;
        animation: slideIn 0.3s ease-out;
        max-width: 300px;
        box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        ${type === 'success' ? 'background: linear-gradient(45deg, #28a745, #20c997);' : 'background: linear-gradient(45deg, #dc3545, #e74c3c);'}
    `;
    
    // Add animation styles
    const style = document.createElement('style');
    style.textContent = `
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        @keyframes slideOut {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(100%); opacity: 0; }
        }
    `;
    document.head.appendChild(style);
    
    document.body.appendChild(notification);
    
    // Auto remove after 3 seconds
    setTimeout(() => {
        notification.style.animation = 'slideOut 0.3s ease-out';
        setTimeout(() => {
            if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
            }
        }, 300);
    }, 3000);
}

function getCsrfToken() {
    const token = document.querySelector('meta[name=csrf-token]');
    if (!token) {
        console.error('CSRF token not found');
        return '';
    }
    return token.getAttribute('content');
}

function selectSearchResult(barcode) {
    document.getElementById('search-results').style.display = 'none';
    scanner.lookupProduct(barcode);
}

// Initialize scanner when page loads
let scanner;
document.addEventListener('DOMContentLoaded', () => {
    // Check browser compatibility first
    if (!navigator.mediaDevices) {
        const errorDiv = document.createElement('div');
        errorDiv.className = 'alert alert-danger';
        errorDiv.innerHTML = `
            <h5><i class="fas fa-exclamation-triangle"></i> Browser Not Supported</h5>
            <p>Your browser doesn't support camera access. Please try:</p>
            <ul>
                <li>Using HTTPS instead of HTTP</li>
                <li>Updating to a modern browser (Chrome, Firefox, Safari, Edge)</li>
                <li>Enabling camera permissions in browser settings</li>
            </ul>
        `;
        
        const container = document.querySelector('.scanner-container');
        container.insertBefore(errorDiv, container.firstChild);
        
        // Disable start button
        const startBtn = document.getElementById('start-scanning');
        if (startBtn) {
            startBtn.disabled = true;
            startBtn.textContent = 'Camera Not Supported';
        }
        return;
    }
    
    scanner = new BarcodeScanner();
});

// Test barcode function
function testBarcode(barcode) {
    console.log('Testing barcode:', barcode);
    if (scanner) {
        scanner.lookupProduct(barcode);
    } else {
        console.error('Scanner not initialized');
    }
}

// Calculate total nutrition for multiple servings
async function calculateNutritionPerServing(barcode) {
    const servingsInput = document.getElementById(`servings-input-${barcode}`);
    const portionSizeInput = document.getElementById(`portion-size-${barcode}`);
    const resultDiv = document.getElementById(`nutrition-per-serving-${barcode}`);
    
    if (!servingsInput || !portionSizeInput || !resultDiv) {
        console.error('Input elements not found');
        return;
    }
    
    const servings = parseInt(servingsInput.value);
    const portionSize = parseInt(portionSizeInput.value);
    
    if (servings <= 0 || portionSize <= 0) {
        showNotification('Please enter valid positive numbers for servings and portion size', 'error');
        return;
    }
    
    try {
        const response = await fetch('/get_product_nutrition_per_serving', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCsrfToken()
            },
            body: JSON.stringify({
                barcode: barcode,
                servings: servings,
                portion_size: portionSize
            })
        });
        
        const data = await response.json();
        console.log('Nutrition calculation response:', data);
        
        if (data.success) {
            // Store the nutrition data for later use
            const nutritionKey = `${barcode}-${portionSize}-${servings}`;
            calculatedNutrition[nutritionKey] = {
                nutrition_label: data.nutrition_label,
                product: data.product,
                nutrition: data.nutrition,
                portion_size: portionSize,
                servings: servings,
                barcode: barcode
            };
            
            console.log('Nutrition label to display:', data.nutrition_label);
            displayNutritionLabel(data.nutrition_label, resultDiv);
            resultDiv.style.display = 'block';
            showNotification(`Total nutrition calculated for ${servings} serving${servings > 1 ? 's' : ''}!`, 'success');
        } else {
            console.error('Nutrition calculation failed:', data.error);
            showNotification('Failed to calculate nutrition: ' + data.error, 'error');
        }
    } catch (error) {
        console.error('Nutrition calculation error:', error);
        showNotification('Failed to calculate nutrition', 'error');
    }
}

// Display formatted nutrition label
function displayNutritionLabel(nutritionLabel, container) {
    console.log('displayNutritionLabel called with:', nutritionLabel, container);
    
    // Check if nutritionLabel has the expected structure
    if (!nutritionLabel || typeof nutritionLabel !== 'object') {
        console.error('Invalid nutrition label data:', nutritionLabel);
        container.innerHTML = '<p class="text-danger">Error: Invalid nutrition data</p>';
        return;
    }
    
    // Extract data from the actual structure returned by the API
    const nutrients = nutritionLabel.display_nutrients || nutritionLabel.nutrients || [];
    const servings = nutritionLabel.servings || 1;
    const macros = nutritionLabel.macros_summary || nutritionLabel.macros || {};
    const perServing = nutritionLabel.per_serving || {};
    const nutrition = nutritionLabel.nutrition || {};
    
    console.log('Nutrients to display:', nutrients);
    console.log('Per serving data:', perServing);
    console.log('Nutrition data:', nutrition);
    console.log('Servings:', servings);
    console.log('Macros:', macros);
    
    let html = `
        <h6><i class="fas fa-utensils"></i> Total nutrition for ${servings} serving${servings > 1 ? 's' : ''} (${(nutritionLabel.portion_size * servings) || (100 * servings)}g total)</h6>
        <div class="nutrition-facts" style="background: white; border: 2px solid #000; padding: 15px; margin: 15px 0; font-family: Arial, sans-serif; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
    `;
    
    let hasData = false;
    
    // If we have display_nutrients array, use that
    if (nutrients && nutrients.length > 0) {
        console.log('Using display_nutrients array');
        nutrients.forEach(nutrient => {
            if (nutrient.value && nutrient.value > 0) {
                hasData = true;
                let nutrientRow = `
                    <div style="border-bottom: 1px solid #ccc; padding: 6px 0; display: flex; justify-content: space-between; align-items: center;">
                        <span><strong>${nutrient.name}</strong></span>
                        <span>${nutrient.value}${nutrient.unit || ''}</span>
                `;
                
                if (nutrient.daily_value) {
                    nutrientRow += `<span style="margin-left: 10px; font-size: 0.9em; color: #666;">(${nutrient.daily_value.toFixed(0)}% DV)</span>`;
                }
                
                if (nutrient.macro_percent) {
                    nutrientRow += `<span style="margin-left: 10px; font-size: 0.9em; color: #666;">(${nutrient.macro_percent.toFixed(0)}% of macros)</span>`;
                }
                
                nutrientRow += `</div>`;
                html += nutrientRow;
            }
        });
    } else if (perServing && Object.keys(perServing).length > 0) {
        // Use per_serving data (this is the main data source for this API)
        console.log('Using per_serving data');
        
        // Helper function to safely get numeric values
        const getValue = (obj, key1, key2) => {
            // Try to get value from the first key
            let nutrientData = obj[key1];
            if (!nutrientData && key2) {
                nutrientData = obj[key2];
            }
            
            if (!nutrientData) return 0;
            
            // Handle different data structures
            let value;
            if (typeof nutrientData === 'object' && nutrientData.value !== undefined) {
                // Structure like: {calories: {value: 557, unit: "kcal"}}
                value = nutrientData.value;
            } else if (typeof nutrientData === 'number') {
                // Direct numeric value
                value = nutrientData;
            } else if (typeof nutrientData === 'string') {
                // String that might be a number
                value = parseFloat(nutrientData);
            } else {
                return 0;
            }
            
            // Convert to number and validate
            const numValue = parseFloat(value);
            return !isNaN(numValue) ? numValue : 0;
        };
        
        // Display main nutrients
        const calories = getValue(perServing, 'calories', 'energy_kcal');
        if (calories > 0) {
            hasData = true;
            html += `<div style="border-bottom: 1px solid #ccc; padding: 6px 0; display: flex; justify-content: space-between; align-items: center;">
                <span><strong>Calories</strong></span>
                <span>${calories.toFixed(0)} kcal</span>
            </div>`;
        }
        
        const protein = getValue(perServing, 'protein', 'proteins');
        if (protein > 0) {
            hasData = true;
            html += `<div style="border-bottom: 1px solid #ccc; padding: 6px 0; display: flex; justify-content: space-between; align-items: center;">
                <span><strong>Protein</strong></span>
                <span>${protein.toFixed(1)} g</span>
            </div>`;
        }
        
        const carbs = getValue(perServing, 'carbs', 'carbohydrates');
        if (carbs > 0) {
            hasData = true;
            html += `<div style="border-bottom: 1px solid #ccc; padding: 6px 0; display: flex; justify-content: space-between; align-items: center;">
                <span><strong>Carbohydrates</strong></span>
                <span>${carbs.toFixed(1)} g</span>
            </div>`;
        }
        
        const fat = getValue(perServing, 'fat', 'total_fat');
        if (fat > 0) {
            hasData = true;
            html += `<div style="border-bottom: 1px solid #ccc; padding: 6px 0; display: flex; justify-content: space-between; align-items: center;">
                <span><strong>Fat</strong></span>
                <span>${fat.toFixed(1)} g</span>
            </div>`;
        }
        
        const fiber = getValue(perServing, 'fiber', 'dietary_fiber');
        if (fiber > 0) {
            hasData = true;
            html += `<div style="border-bottom: 1px solid #ccc; padding: 6px 0; display: flex; justify-content: space-between; align-items: center;">
                <span><strong>Fiber</strong></span>
                <span>${fiber.toFixed(1)} g</span>
            </div>`;
        }
        
        const sugars = getValue(perServing, 'sugars', 'sugar');
        if (sugars > 0) {
            hasData = true;
            html += `<div style="border-bottom: 1px solid #ccc; padding: 6px 0; display: flex; justify-content: space-between; align-items: center;">
                <span><strong>Sugars</strong></span>
                <span>${sugars.toFixed(1)} g</span>
            </div>`;
        }
        
        const sodium = getValue(perServing, 'sodium', 'salt');
        if (sodium > 0) {
            hasData = true;
            html += `<div style="border-bottom: 1px solid #ccc; padding: 6px 0; display: flex; justify-content: space-between; align-items: center;">
                <span><strong>Sodium</strong></span>
                <span>${sodium.toFixed(1)} mg</span>
            </div>`;
        }
    }
    
    if (!hasData) {
        html += `<p class="text-warning">No nutrition data available to display.</p>`;
        console.warn('No nutrition data found in any expected format');
    }
    
    // Add macro summary if available
    if (macros && Object.keys(macros).length > 0) {
        html += `
            <div style="margin-top: 15px; padding-top: 10px; border-top: 2px solid #000;">
                <strong>Macronutrient Breakdown:</strong>
                <div style="display: flex; justify-content: space-between; margin-top: 5px;">
        `;
        
        if (macros.protein_percent) {
            html += `<span>Protein: ${macros.protein_percent.toFixed(0)}%</span>`;
        }
        if (macros.carbs_percent) {
            html += `<span>Carbs: ${macros.carbs_percent.toFixed(0)}%</span>`;
        }
        if (macros.fat_percent) {
            html += `<span>Fat: ${macros.fat_percent.toFixed(0)}%</span>`;
        }
        
        html += `
                </div>
            </div>
        `;
    }
    
    html += `
        </div>
        <p style="font-size: 12px; color: #666; margin-top: 10px;">
            <i class="fas fa-info-circle"></i> 
            Daily values are based on a 2000 calorie diet. Your daily values may be higher or lower depending on your calorie needs.
        </p>
    `;
    
    console.log('Generated HTML for nutrition display:', html);
    container.innerHTML = html;
}

// Nutrition logging functions
function showLogNutritionModal(barcode) {
    // Get the product data from cache or fetch it
    const productInfo = scannedProducts[barcode];
    if (!productInfo) {
        showNotification('Product information not available', 'error');
        return;
    }
    
    // Populate modal with product information
    document.getElementById('log-product-name').value = productInfo.name || productInfo.product_name || '';
    document.getElementById('log-brand').value = productInfo.brand || productInfo.brands || '';
    document.getElementById('log-barcode').value = barcode;
    
    // Check if nutrition has been calculated for this product
    console.log('Looking for calculated nutrition for barcode:', barcode);
    console.log('Available nutrition keys:', Object.keys(calculatedNutrition));
    
    // Try to find calculator inputs from the page
    const portionSizeInput = document.getElementById(`portion-size-${barcode}`);
    const servingsInput = document.getElementById(`servings-input-${barcode}`);
    
    let portionSize = 100;
    let servings = 1;
    
    if (portionSizeInput && servingsInput) {
        portionSize = parseInt(portionSizeInput.value) || 100;
        servings = parseInt(servingsInput.value) || 1;
        console.log('Found calculator inputs:', portionSize + 'g,', servings, 'servings');
    }
    
    // Look for calculated nutrition data
    const nutritionKey = `${barcode}-${portionSize}-${servings}`;
    console.log('Looking for nutrition key:', nutritionKey);
    
    if (calculatedNutrition[nutritionKey]) {
        console.log('Found calculated nutrition, using calculated values');
        document.getElementById('log-portion-size').value = portionSize;
        document.getElementById('log-servings').value = servings;
        
        // Update nutrition preview
        updateNutritionPreview(barcode, portionSize, servings);
    } else {
        console.log('No calculated nutrition found, using defaults');
        // Reset portion and servings to defaults
        document.getElementById('log-portion-size').value = 100;
        document.getElementById('log-servings').value = 1;
        
        // Clear nutrition preview
        const previewElement = document.getElementById('nutrition-preview');
        if (previewElement) {
            previewElement.innerHTML = '<small class="text-warning">⚠️ Please calculate nutrition first for accurate values</small>';
        }
    }
    
    // Show the modal
    $('#logNutritionModal').modal('show');
}

// Update nutrition preview in the modal
function updateNutritionPreview(barcode, portionSize, servings) {
    const nutritionKey = `${barcode}-${portionSize}-${servings}`;
    const nutritionData = calculatedNutrition[nutritionKey];
    
    if (nutritionData && nutritionData.nutrition_label) {
        const calories = nutritionData.nutrition_label.nutrients?.find(n => n.name === 'Calories')?.value;
        if (calories) {
            const previewElement = document.getElementById('nutrition-preview');
            if (previewElement) {
                previewElement.innerHTML = `<small class="text-success">✅ Total: ${calories} calories for ${servings} serving(s) of ${portionSize}g each (${portionSize * servings}g total)</small>`;
            }
        }
    }
}

function logToNutritionTracker() {
    const barcode = document.getElementById('log-barcode').value;
    const portionSize = parseFloat(document.getElementById('log-portion-size').value);
    const servings = parseFloat(document.getElementById('log-servings').value);
    const mealType = document.getElementById('log-meal-type').value;
    const notes = document.getElementById('log-notes').value;
    
    if (!barcode || portionSize <= 0 || servings <= 0) {
        showNotification('Please fill in all required fields with valid values', 'error');
        return;
    }
    
    // Show loading state
    const logButton = document.querySelector('#logNutritionModal .btn-primary');
    const originalText = logButton.innerHTML;
    logButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Logging...';
    logButton.disabled = true;
    
    fetch('/log-from-barcode', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCsrfToken()
        },
        body: JSON.stringify({
            barcode: barcode,
            portion_size: portionSize,
            servings: servings,
            meal_type: mealType,
            notes: notes
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            $('#logNutritionModal').modal('hide');
            showNotification('Successfully logged to nutrition tracker!', 'success');
            
            // Reset form
            document.getElementById('log-portion-size').value = 100;
            document.getElementById('log-servings').value = 1;
            document.getElementById('log-meal-type').value = 'snack';
            document.getElementById('log-notes').value = '';
        } else {
            showNotification('Failed to log nutrition: ' + data.error, 'error');
        }
    })
    .catch(error => {
        console.error('Error logging nutrition:', error);
        showNotification('Failed to log nutrition', 'error');
    })
    .finally(() => {
        // Restore button state
        logButton.innerHTML = originalText;
        logButton.disabled = false;
    });
}

// Add to Pantry function
function addToPantry(barcode, buttonElement = null) {
    console.log('Adding to pantry:', barcode);
    
    // Get the product data from cache
    const productInfo = scannedProducts[barcode];
    if (!productInfo) {
        showNotification('Product information not available', 'error');
        return;
    }
    
    // Store original button text
    let originalText = '';
    if (buttonElement) {
        originalText = buttonElement.innerHTML;
        buttonElement.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Adding...';
        buttonElement.disabled = true;
    }
    
    // Prepare data for pantry
    const pantryData = {
        barcode: barcode,
        product_name: productInfo.name || productInfo.product_name || `Product ${barcode}`,
        brand: productInfo.brand || productInfo.brands || '',
        quantity: 1, // Default quantity
        unit: 'units', // Default unit
        nutrition: {} // Will include nutritional data if available
    };
    
    // Include nutritional data if calculated
    const portionSizeInput = document.getElementById(`portion-size-${barcode}`);
    const servingsInput = document.getElementById(`servings-input-${barcode}`);
    
    if (portionSizeInput && servingsInput) {
        const portionSize = parseInt(portionSizeInput.value) || 100;
        const servings = parseInt(servingsInput.value) || 1;
        const nutritionKey = `${barcode}-${portionSize}-${servings}`;
        
        if (calculatedNutrition[nutritionKey]) {
            pantryData.nutrition = {
                portion_size: portionSize,
                servings: servings,
                data: calculatedNutrition[nutritionKey]
            };
            console.log('Including nutrition data in pantry item');
        }
    }
    
    // Send to pantry endpoint
    fetch('/pantry/add_from_barcode', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCsrfToken()
        },
        body: JSON.stringify(pantryData)
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            const action = data.action === 'updated' ? 'Updated' : 'Added';
            showNotification(data.message || `${action} ${pantryData.product_name} to pantry`, 'success');
            
            // Update button to show success
            if (buttonElement) {
                buttonElement.innerHTML = '<i class="fas fa-check"></i> Added to Pantry';
                buttonElement.classList.remove('btn-warning');
                buttonElement.classList.add('btn-success');
                
                // Reset button after delay
                setTimeout(() => {
                    buttonElement.innerHTML = originalText;
                    buttonElement.classList.remove('btn-success');
                    buttonElement.classList.add('btn-warning');
                }, 2000);
            }
        } else {
            showNotification('Failed to add to pantry: ' + (data.error || 'Unknown error'), 'error');
        }
    })
    .catch(error => {
        console.error('Error adding to pantry:', error);
        showNotification('Failed to add to pantry', 'error');
    })
    .finally(() => {
        // Restore button state if failed
        if (buttonElement && !buttonElement.classList.contains('btn-success')) {
            buttonElement.innerHTML = originalText;
            buttonElement.disabled = false;
        }
    });
}

// Helper function to get CSRF token
function getCsrfToken() {
    const token = document.querySelector('meta[name="csrf-token"]');
    return token ? token.getAttribute('content') : '';
}
</script>

<!-- Log to Nutrition Tracker Modal -->
<div class="modal fade" id="logNutritionModal" tabindex="-1" role="dialog">
    <div class="modal-dialog" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">
                    <i class="fas fa-chart-line"></i> Log to Nutrition Tracker
                </h5>
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
            <div class="modal-body">
                <form id="logNutritionForm">
                    <input type="hidden" id="log-barcode">
                    
                    <div class="form-group">
                        <label for="log-product-name">Product Name</label>
                        <input type="text" class="form-control" id="log-product-name" readonly>
                    </div>
                    
                    <div class="form-group">
                        <label for="log-brand">Brand</label>
                        <input type="text" class="form-control" id="log-brand" readonly>
                    </div>
                    
                    <div class="row">
                        <div class="col-md-6">
                            <div class="form-group">
                                <label for="log-portion-size">Portion Size (grams)</label>
                                <input type="number" class="form-control" id="log-portion-size" value="100" min="1" max="5000" required>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="form-group">
                                <label for="log-servings">Number of Servings</label>
                                <input type="number" class="form-control" id="log-servings" value="1" min="0.1" step="0.1" max="100" required>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Nutrition Preview -->
                    <div class="form-group">
                        <label>Nutrition Preview</label>
                        <div id="nutrition-preview" class="alert alert-info py-2">
                            <small class="text-muted">Calculate nutrition first for accurate preview</small>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label for="log-meal-type">Meal Type</label>
                        <select class="form-control" id="log-meal-type" required>
                            <option value="breakfast">Breakfast</option>
                            <option value="lunch">Lunch</option>
                            <option value="dinner">Dinner</option>
                            <option value="snack" selected>Snack</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label for="log-notes">Notes (optional)</label>
                        <textarea class="form-control" id="log-notes" rows="2" placeholder="Additional notes about this food entry..."></textarea>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" onclick="logToNutritionTracker()">
                    <i class="fas fa-save"></i> Log Entry
                </button>
            </div>
        </div>
    </div>
</div>

<script>
// Add event listeners for modal inputs to update nutrition preview
document.addEventListener('DOMContentLoaded', function() {
    const logPortionSize = document.getElementById('log-portion-size');
    const logServings = document.getElementById('log-servings');
    
    if (logPortionSize && logServings) {
        logPortionSize.addEventListener('input', function() {
            const barcode = document.getElementById('log-barcode').value;
            if (barcode) {
                updateNutritionPreview(barcode, parseInt(this.value) || 100, parseInt(logServings.value) || 1);
            }
        });
        
        logServings.addEventListener('input', function() {
            const barcode = document.getElementById('log-barcode').value;
            if (barcode) {
                updateNutritionPreview(barcode, parseInt(logPortionSize.value) || 100, parseInt(this.value) || 1);
            }
        });
    }
});
</script>

<style>
/* Shopping List Modal Styles */
#shoppingListModal .list-group-item {
    transition: all 0.3s ease;
    border: 1px solid #dee2e6;
    margin-bottom: 0.5rem;
    border-radius: 8px;
}

#shoppingListModal .list-group-item:hover {
    background-color: #f8f9fa;
    border-color: #007bff;
    transform: translateY(-1px);
}

#shoppingListModal .list-group-item:active,
#shoppingListModal .list-group-item.active {
    background-color: #007bff;
    border-color: #007bff;
}

#shoppingListModal .fas.fa-star {
    color: #ffc107;
}

#shoppingListModal .modal-body {
    max-height: 60vh;
    overflow-y: auto;
}

/* Loading state for buttons */
.btn .fa-spinner {
    animation: spin 1s linear infinite;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}
</style>

</script>
{% endblock %}
